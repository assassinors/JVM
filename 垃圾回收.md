### 垃圾收集

- 引用计数算法
  - 引用计数器：有一个地方引用加1，引用失效减1，计数器为0的对象就是不可能再被使用的
  - 缺点：很难解决对象之间循环引用的问题
- 可达性分析算法
  - “GC Roots”对象做为起点开始向下搜索，搜索走过的路径称为引用链
  - 如果某对象到GC Root不可达，则被判定为可回收对象
  - GC Roots:
    - 虚拟机栈中引用的对象
    - 方法区中类静态属性引用的对象
    - 方法区中常量引用的对象
    - 本地方法栈中JNI引用的对象
- 引用分类
  - 强引用：普遍存在的引用
  - 软引用：有用但非必需
  - 弱引用：有用非必需对象，比软引用更弱
  - 虚引用：不会影响对象的生存时间
- 两次标记
  - 第一次标记是不可达分析之后，判断是否有必要执行<finalize()>方法
  - 如果有必要执行，对象放置在F-Queue,虚拟机创建一个Finalizer线程去执行
  - 对象能在finalize()中拯救自己

##### 回收方法区

- 废弃常量
- 无用的类
  1. 类的所有实例都被回收
  2. 加载该类的ClassLoader已经被回收
  3. 该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法

##### 垃圾回收算法

1. 标记-清除算法
   - 缺点：效率问题，空间问题，产生大量内存碎片
2. 复制算法
   - 可用内存分为两块，每次使用一块，一块满了就将存活对象复制到另一块上，再把已使用过的内存空间一次清理掉
   - 不用考虑内存碎片，但是内存缩小为了原来的一半
   - 现代虚拟机将新生代划分为较大的Eden空间和两块较小的Survivor空间，每次使用Eden和一块Survivor。HotSpot默认比例为8：1。
   - 当Survior空间不够时需要使用其他内存（年老代）进行分配担保（Handle Promotion）
3. 标记-整理算法
   - 存活对象向一端移动
4. 分代收集算法
   - 新生代复制算法，老生代标记-清理或标记-整理

##### HotSpot的算法实现

- 枚举根节点：GC进行时必须停顿所有Java执行线程
  - 准确式GC
- 安全点：在特定位置上才停顿，安全点的选定是以程序是否具有让程序长时间执行特征为标准选定的
- 让所有线程跑到安全点再停顿
  - 抢先式中断：首先把所有线程中断，如果不在安全点则恢复让其跑至安全点
  - 主动式中断：GC设置标志，线程轮询，标志为真主动挂起
- 安全区域：一段代码片段中，引用关系不会发生变化。在这个区域中的任何地方发起GC都是安全的

##### 垃圾收集器

- 7种

1. Serial收集器
   - 单线程
2. ParNew
   - Serial的并行多线程版本
3. Parallel Scavenge
   - 达到一个可控制的吞吐量。吞吐量指的是CPU用于运行用户代码的时间与CPU总消耗时间的比值
   - 吞吐量优先的收集器
   - GC自适应的调节策略
4. Serial Old收集器
   - Serial的老年代版本
5. Parallel Old
   - Parallel Scavenge的老年代版本
6. CMS
   - 获取最短回收停顿时间为目标
   - 四个步骤：
     - 初始标记：标记GC Roots能直接关联到的对象
     - 并发标记：GC Roots Tracing过程
     - 重新标记：修正并发标记期间因用户程序继续运作而导致的标记产生变动的那一部分对象的标记记录
     - 并发清除
   - 缺点:
     - 对CPU资源敏感
     - 无法处理浮动垃圾，可能出现“Concurrent Mode Failure”失败而导致另一次Full GC的产生。
     - 标记-清除产生碎片
7. G1收集器
   - 并行与并发
   - 分代收集
   - 空间整合
   - 可预测的停顿
   - 运作过程
     - 初始标记
     - 并发标记
     - 最终标记
     - 筛选回收

##### 内存分配与回收策略

- 对象优先在Eden分配
- 大对象直接进入老年代
- 长期存活的对象将进入老年代
- 动态对象年龄判定
- 空间分配担保

